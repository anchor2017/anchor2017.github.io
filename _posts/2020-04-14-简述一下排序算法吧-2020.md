---
layout:     post
title:      排序算法思想简述
subtitle:   
date:       2020-04-14
author:     蔡银锚
header-img:
catalog: true
tags:
    - 排序算法
---

（以下无例外基于升序）

### 插入排序
插入排序可能是最近才开始关注的一个算法，在数据基本有序的情况下，居然可以实现O(N)的时间复杂度。空间是O(1)。
算法思想是取后一个数字和前面的数组（已经排好序），从后面开始向前面进行比较，当发现他比前一个数字大，就可以不用继续比较下去了。
因为他的位置已经是有序的了。接着，可以考虑下一个数字了，所有数字都考虑全，排序也就排好了。稳定算法。

### 基数排序
一个对位数基本一致，不够位数的，可能还需要高位补0，这步感觉还挺麻烦的，是转化为字符串比较呢，不用计算，还是使用/，%在程序里面直接计算边界呢，
毕竟0/10或者0%10也是0，两种方式吧。基数排序只可以使用从低位到高位的一个比较，不可以从高位到低位，因为在下一次排序的时候，
可能会遇到大的数因为下一个位的数字小而排在前面。时间复杂度是最大的那个位数k（即K轮），乘以数字规模n，即O(kn)，空间复杂度，
这里需要用额外的空间，可以使用10*n 的一个二维空间，挺大的。或者类似存储图（矩阵）的一个链表的方式来存储，或者是C++里面的
vector<int> p[10]存储应该也行。
所以，额外空间起码也得O(n)，不知道有没有O(1)的？以后再看看吧。稳定算法。

### 外部归并排序
这类算法也是最近才了解到的，考虑外部排序的方式，也就是内存放不下，大部分数据在磁盘这样。
如果只是查找top10这样的数据话，可以直接使用堆排序，也就是每来一个数据，看他是否可以放入堆中。
而如果要全部排序的话，可以使用归并排序。准确地说，将一大块数据分成多个小块，每个小块应该足够放入内存中，
先保证这几个小块有序了，每次取出这些小块的前一小部分数据（小小块）进行归并。
当这一小小块数据使用完之后，继续取这一小小块所属的小块进行排序，所有数据取完，所有数据都有序了。
当时，有个面试官问道，不会乱吗，理论上应该是不会的，因为，你每次归并，都取出的是小小块的最小值，也就是某一个小小块的第一位，
下一次，再取下一位，第二小的，当输出缓冲区满了，直接写入文件，因为这部分已经是在其位的数据了。
时间复杂度其实不是很明白为什么是O(NlongN)，而不是O(longN)的？空间复杂度大概就是输出缓冲区了吧。稳定算法。




