## 标题 进行单片机或者其他机器之间的通信步骤
1 通信是串行还是并行
2 串行是大端发送还是小端发送
3 串行是异步还是同步发送
4 串行通信采用什么协议 SPI, I2C
(SPI：SCK, MISO, MOSI)
(I2C: SCK, SDA)
5 查看datasheet注意事项
##标题 串口通信
串口通信中除了特殊功能寄存器之外，还有在物理上是两个独立的寄存器，分别为发送寄存器SBUF和接收寄存器SBUF（这两个寄存器在单片机和计算机中都有）
计算机读取数据：计算机读SBUF（读取接收缓存器）
计算机发送数据：计算机写入SBUF（送入数据给发送寄存器）
单片机读取数据：单片机读取SBUF（读取接收缓存器）
单片机发送数据：单片机写入SBUF（送入数据给发送寄存器）
##标题 波特率和比特率
1 单片机或计算机在串口通信时的速率。指的是信号被调制以后在单位时间内的变化，即单位时间内载波参数变化的次数，如每秒钟传送240个字符，而每个字符格式包含10位（1个起始位，1个停止位，8个数据位），这时的波特率为240Bd，比特率为10位*240个/秒=2400bps。又比如每秒钟传送240个二进制位，这时的波特率为240Bd，比特率也是240bps。(但是一般调制速率大于波特率，比如曼彻斯特编码）。波特率，可以通俗的理解为一个设备在一秒钟内发送（或接收）了多少码元的数据。它是对符号传输速率的一种度量，1波特即指每秒传输1个码元符号（通过不同的调制方式，可以在一个码元符号上负载多个bit位信息），1比特每秒是指每秒传输1比特（bit）。 单位“波特”本身就已经是代表每秒的调制数，以“波特每秒”（Baud per second）为单位是一种常见的错误。
2 模拟线路信号的速率，以波形每秒的振荡数来衡量。如果数据不压缩，波特率等于每秒钟传输的数据位数，如果数据进行了压缩，那么每秒钟传输的数据位数通常大于调制速率，使得交换使用波特和比特/秒偶尔会产生错误。
##标题 在具体操作串行口之前对单片机的一些与串口有关的特殊功能寄存器进行初始化
设置产生波特率的定时器1(TMOD)，串行口控制(SCON)和中断控制(IE, IP寄存器，也可以不设置)



#Altium Designer  (DXP)
1 新建工程
 新建原理图文件
 新建原理图库
 2 在原理图库上画元件
 3 画封装库
 4 新建一个PCB文件
 （布局）
 （进行电气检查）
 5 保存PCB文件


##skill
1 出现引脚时按Tab可以修改引脚参数
2 按空格键元件可以旋转
3 十字交叉点是以后放置元件的基准点，元件中心应与其对应
4 画sch的元件，功能上只需要把元件的引脚画出来即可，且引脚位置可以不按实物的顺序来，在此基础上也可以把它画得更像元器件实物，以后在pcb布局连线有利
5 按Tab键可以设置孔径，焊盘的大小
6 按Ctrl+M可以测两个焊盘之间的间距
7 要求画元件的原理图和封装时的Designator编号一定要相同
8 要求画封装的时候引脚的位置要百分百和实物相同
9 一般的错误有：没封装，封装管脚和原理图不能对应，网络标号没标到
10 连线时尽量不要出现90°转角，电源线宽一点

##电路板雕刻机

##skills
1 Ctrl+Tab --> 窗口的切换



#上拉电阻
上拉就是将不确定的信号通过一个电阻钳位在高电平，电阻同时起限流作用。下拉同理。也是将不确定的信号通过一个电阻钳位在低电平。
上拉是对器件输入电流，下拉是输出电流;强弱只是上拉电阻的阻值不同，没有什么严格区分;对于非集电极(或漏极)开路输出型电路(如普通门电路)提升电流和电压的能力是有限的，上拉电阻的功能主要是为集电极开路输出型电路输出电流通道。



##程序

- 程序的头文件（即.h文件），自己定义时使用#ifndef, #def, 要有#endif。否则会出现预编译错误。
- 编写程序的时候，尽量将具有相同固定功能的代码封装起来（注意传入参数（数组的话，传入首地址即可））。
- 编写程序的时候一个函数尽量不要太多行（不要超过100行），将函数模块化并分割出来，以便后续调试，方便找bug.
- 工程文件：先编译(compling)后链接(linking)

##不将全局变量的定义放在头文件的原因

- 跟踪难度大。工程很大的话，那么包含这个头文件的文件都有可能修改了其值，出了问题不好排查
- 许多嵌入式系统内存不像电脑那么大，如果在头文件中声明全局变量，那么所有引用该头文件的文件都将为此变量分配内存，这样会降低内存的利用率，有时几K就是致命。
##keil中的错误或者警告提示

- WARNING L1: UNRESOLVED EXTERNAL SYMBOL （未分配的外部符号） ： 
- ERROR L104: MULTIPLE PUBLIC DEFINITIONS   ： 头文件包含中重复定义了（比如在一个头文件里面定义了int week; 又在多个c文件中包含了就会有命名的冲突）。解决方法：一般定义都放在.C文件中，要是需要给其他模块用，就在头文件里面用extern声明（比如：extern int week）。



##舵机原理及其应用

####舵机(Servo)：
- 优点：结构紧凑，易安装调试，控制简单，大扭力，成本较低
- 也称伺服机。主要性能取决于最大力矩和工作速度（一般以秒/60°为单位）。
- 在航模遥控系统中，控制信号右接收机的通道进入信号调制芯片，获得直流偏置电压。
  - 直流偏置电压：晶体管的直流偏置电压定义为晶体管未加信号时，其基极与发射极之间所加的直流电压。
- 舵机内部有一个基准电路，产生周期为20ms，宽度为1.5ms的基准信号，并将获得的直流偏置电压与电位器的电压比较，获得电压差输出。最后将电压差的正负输出到电机驱动芯片决定电机的正转反转。
- 当电机转速一定时，通过级联减速齿轮带动电位器旋转，使电压差为0，电压停止转动。
- PWM就是脉冲宽度调制的英文缩写，方波高电平时间跟周期的比例叫占空比，例如1秒高电平1秒低电平的PWM波占空比是50%



## 嵌入式

- 如何移植的操作系统？（任务上下文save和restore）
- ARM架构，和其他架构的不同？
- volatile、static关键字？



## 仿真器

- 由于Keil公司被ARM公司收购，其改名为MDK，使用Keil5或者Keil4才可以编程ARM芯片。
- 安装注意事项：
  - 安装路径不能带中文，必须是英文路径
  - 目录不能跟51或者Keil4冲突
  - 必须添加芯片包，不然没法使用
  - 使用时出现莫名其妙的错误，先到网上查找解决方法，莫乱阵脚
- ULink是一个仿真器，支持下载程序，在线硬件仿真。网上卖的ULink是盗版的，它会出现很多问题，正版的要两千五百块一个。
- 串口无法硬件仿真，在线调试。
- JTag是一种国际标准，是一种国际上的通信协议。JTAG包括了SW
- 1、遵循ARM公司的CMSIS-DAP标准，支持所有基于Cortex-M内核的单片机 2、属于HID设备，跟鼠标键盘一样，无需安装驱动 3、支持XP/WIN7/WIN8/WIN10 这四个操作系统 4、支持JTAG和SW下载模式，可在线调试和硬件仿真
- JTAG有几根线包含了SW
- SW所需的线：TMS、GND、TCK、RESET
- JTAG所需的线：TDI、TMS、TCK、TDO、RESET
- STM32F10x霸道版本内存：512K



# ADC(DMA)

1. 注意：
   1. 通过特定的外设选择恰当的DMA通道(DMAx_Channelx)
   2. 通过特定的引脚选择恰当的ADC通道(比如PC0的ADC123_IN10)
2. 步骤：
   1. ADC_GPIO配置
   2. DMA配置
   3. ADC配置
3. que:
   1. DMA传输中的Circular Mode和Normal Mode指的是什么？
   2. DMA的DMA_IT_TC中断标志位是指传输完成吗？可以表示外设到存储器中存储器满了吗？
4. 示例：

```c
//ADC配置
void ADC_Config()
{
    ADC_InitTypeDef ADC_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    ADC_InitStructure.ADC_Mode=ADC_Mode_Independent;
    ADC_InitStructure.ADC_ScanConvMode=DISABLE;
    ADC_InitStructure.ADC_ContinuousConvMode=ENABLE;
    ADC_InitStructure.ExternalTrigConv=ADC_ExternalTrigInjecConv_None;
    ADC_InitStructure.ADC_DataAlign=ADC_DataAlign_Right;
    ADC_InitStructure.ADC_NbrOfChannel=ADC_Channel_10;
    
    ADC_Init(ADC1, &ADC_InitStructure);
    ADC_CMD(ADC1, ENABLE);
    
    //ADC的DMA请求
    //ADC_DMACmd(ADC1, ENABLE);
}

//ADC_DMA配置
//宏定义
#define ADC1DRAddr 0x40012400+0x4c
//全局变量
//extern uint16_t MemoryArr[1000];

void ADC_DMA_Config()
{
    DMA_InitTypeDef DMA_InitStructure;
    
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_DMA1, ENABLE);
    DMA_InitStructure.DMA_PeripheralBaseAddr=ADC1DRAddr;
    DMA_InitStructure.DMA_MemoryBaseAddr=MemoryArr;
    DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralSRC;
    //(ADC_DR(16 bits))/(DMA_PeripheralDataSize_HalfWord(16 bits))=1
    DMA_InitStructure.DMA_BufferSize=1;
    DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;
    DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;
    DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;
    DMA_InitStructure.DMA_Priority=DMA_Priority_VeryHigh;
    DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;
    
    DMA_Init(DMA1_Channel1, ENABLE);
    DMA_CMD(DMA1_Channel1, ENABLE);
}
```

# DMA(USART)

1. 注意：
   1. 串口的数据寄存器有效位为0-8，其余为保留位。所以串口外设的数据大小(DataSize)为8位。
   2. 外设的基地址指的应该是串口的数据寄存器的地址映射。
   3. 串口DMA配置中的数据大小，是指传输数据的时候的数据大小。也就是每次以多少位的数据传输。
   4. 串口DMA传输中的 DMA_BufferSize 指的是什么？（是指发送方的总的数据位数(ADC_DR为16位)除以每个数据单元所占的位数(DMA_PeripheralDataSize or DMA_PeripheralDataSize members)吗？比如 DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord 且ADC的ADC_DR寄存器的规则DATA接收是16位的，所以16/16=1.又比如内存大小为 uint8_t SendBuff[SENDBUFF_SIZE];(#define SENDBUFF_SIZE 5000),8*5000=40000. DMA_MemoryDataSize=DMA_MemoryDataSize_Byte；所以 40000/8=5000.也就是BufferSize的大小为5000(SENDBUFF_SIZE)）。
   5. DMA1的Channel4是USART_TX.
   6. 选择恰当的 DMA 通道，这个通道并不是随便选择的，而是要根据 DMA 的请求映像来设置。
2. 步骤：
   1. 串口配置及串口所需引脚配置
   2. DMA配置(通过特定的外设选择恰当的DMA通道)
3. 示例：

```c
//DMA配置

//宏定义
#define BUFFERSIZE 5000
//内存块
int8_t MemoryArr[BUFFERSIZE];
//外设地址
#define USARTDRAddr 0x40013800+0x04

void DMA_Config()
{
    DMA_InitTypeDef DMA_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_DMA1, ENABLE);
    
    DMA_InitStructure.DMA_PeripheralBaseAddr=USARTDRAddr;
    DMA_InitStructure.DMA_MemoryBaseAddr=MemoryArr;
    DMA_InitStructure.DMA_DIR=DMA_DIR_PeripheralDST;
    DMA_InitStructure.DMA_BufferSize=BUFFERSIZE;//缓冲区大小
    
    DMA_InitStructure.DMA_PeripheralInc=DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc=DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte；
    DMA_InitStructure.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte；
    DMA_InitStructure.DMA_Mode=DMA_Mode_Normal;//这里的DMA_Mode是指什么？
    DMA_InitStructure.DMA_Priority=DMA_Priority_VeryHigh;
    DMA_InitStructure.DMA_M2M=DMA_M2M_Disable;
    
    DMAInit(DMA1_Channel4, ENABLE);
    
    DMA_Cmd(DMA1_Channel4, ENABLE);
}
```

# 呼吸灯

1. 注意：
   1. 使用stm32定时器3的通道3实现呼吸灯的效果。
   2. 要实现每次更改TIMx_CCR的值，可以在每次上溢进入中断服务程序的时候修改。
   3. PWM表，也就是呼吸灯有40个状态（亮度），每个状态持续的时间为10个中断周期，也就是10次中断之后就进入下一个状态了（可能和之前是同一个状态）。在每一次进入中断的时候改变。
   4. 定时器周期 TIM_Period是固定的(255)。
   5. 呼吸灯每个状态的持续次数（时间）控制由 TIM_Pulse 决定。
   6. stm32有八个定时器，TIM1和TIM8是高级控制定时器；TIM6和TIM7是高级定时器；其它是基本定时器。每个定时器有4个通道。
   7. 计数器在计数（每计一个数的时间是根据频率算出来的）到比较值的时候产生中断。如果要产生呼吸灯，那么每次放入的比较值就要不同。
   8. 定时器最大的时钟频率为72MHz，配合预分频可以灵活的时钟周期。
   9. 定时器可以工作在4个不同的通道，可以使用TIM定时器在同一时间提供4路不同的时钟周期。
2. 步骤：
   1. 配置呼吸灯要用到的引脚
   2. 配置定时器3中断（使用定时器主要用来精确控制它的呼吸频率，即一个周期持续的时间）
   3. 配置定时器3的时钟频率，主要是它的中断事件
   4. 编写定时器3中断服务程序

```c
//中断服务程序的编写，最主要的一部分
void TIM3_Handdler()
{
    
}
```

# ADC多通道转换

1. 注意：
   1. ADC1具有DMA通道1，ADC2没有DMA通道，ADC3具有DMA3。其中，每个ADC通道具有16个外部通道和2个内部通道。ADC1对应DMA1的通道1，注意DMA1通道1的写法为：DMA1_Channel1(这里后面的数字1前面是一个字母L)
   2. DMA里面的外设基地址指的是ADC1,ADC3(stm32f10x.h)的DR寄存器的起始地址；而内存的基地址可以使用数组名表示。
   3. 当使用ADC1的时候为单模式，当使用ADC1和ADC2或者还有ADC3的时候，就会使用多模式。
   4. ADCx，ADC_Channelx，DMAx，引脚，端口，外设的时钟都可以使用宏定义
   5. DAC的触发方式有八种，六种是定时器触发，一个EXTI11_Tim8触发和软件触发。
   6. ADC1虽然有16条通道，但是还是需要给ADC1的每个通道配置一个优先级。之后，ADC1的不同通道就可以采集不同的事件。
   7. DMA和ADC配置之后要进行初始化和使能DMA通道和使能ADC的DMA请求。
2. ADC的GPIO配置
   1. 定义结构体
   2. 开ADC外设时钟
   3. 定义引脚
   4. 模拟输入
   5. 初始化
3. ADC配置与DMA配置
   1. ​

```c
//GPIO配置
```

# program

- 编写头文件

```c
#ifndef ```
#define ```

#include "stm32f10x.h"//32的所以头文件和main.c都包含这一个头文件
#include ""     //包含bsp文件
#include <>

#define ```  //宏定义（引脚，端口，时钟）
//带参宏
#define LED1(a)	if (a)	\
		GPIO_SetBits(GPIOB,GPIO_Pin_0);\
		else		\
		GPIO_ResetBits(GPIOB,GPIO_Pin_0)
(extern) typedef struct     //结构体
{
    
}time;
(extern) typedef enum   //枚举变量
{
    
}color;


void ```    //函数声明
int ```

#endif
```

- 编写main.c文件

```c
#include "stm32f10x.h"
#include ""  //bsp文件
#include <>

 //声明一些变量
extern __IO uint16_t ADC_ConvertedValue[NOFCHANEL]={0, 0, 0, 0};

void Delay(__IO uint32_t nCount)
{
    for(; nCount>0; nCount--);
}

int main(void)
{
    
}
```

- 编写bsp.c文件

```c
 #include ""  //bsp文件

 //声明一些局部变量
 static __IO u32 TimingDelay;       //静态变量
 
 //函数定义（配置函数都声明为静态变量，也就是只有在这个函数里面才能修改这个函数）
 static void ADCx_GPIO_Config(void)
 {
     
 }
 
 static void ADCx_Mode_Config(void)
 {
    
 }
 
 static void NVIC_Configuration(void)
 {
     
 }
```

# 电源模式的区别

睡眠模式只要调用__WFI(); 停止模式还有使能电源管理单元的时钟，然后才可以配置相关寄存器。待机模式还要加上使能WakeUp引脚的唤醒功能。

# 待机模式

（先通过中断进入线中断，才能进入待机模式）

```c
uint8_t LongKeyTest(void)
{
    uint8_t downCount=0;
    uint8_t upCount=0;
    
    while(1)
    {
    	if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == RESET)
    	{
            LED1(ON);LED2(ON);LED3(ON);
            
            Delay(0xFFFF);
            if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_13) == RESET)
                {
                downCount++;
                if(downCount>100)
                {
                    LED1(OFF);LED2(OFF);LED3(OFF);
                    return 1;
                }
            }
    	}
        else
        {
            upCount++;
            if(upCount>5)
            {				
            	LED1(OFF);LED2(OFF);LED3(OFF);
            	return 0;
            }
        }
    }
}

void EXTI15_10_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line13) == SET)
    {
        //SYSCLKConfig_STOP();	
        if(LongKeyTest())
        {
            PWR_WakeUpPinCmd(ENABLE);
            
            PWR_EnterSTANDBYMode();
        }
        
        EXTI_ClearITPendingBit(EXTI_Line13);
    }
}
```

# 按键线中断

- 那个中断向量表在misc.h里面，记住是头文件里面 .c文件里面没有。（好像配置外设的时候，都有两步，一步是将结构体init，一步是cmd=ENABLE）
- 步骤：

1. 配置引脚和线中断
2. 设置NVIC优先级
3. 编写中断服务程序

- 注意：

1. 要使用GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
2. 可以将NVIC函数放在EXTI里面
3. 不需要设置频率，要设置上拉输入(可是就算设置了频率和浮空输入，也照样可以正常使用是为什么？)
4. 中断函数名在stm32f10x_md.s启动汇编文件里面有些，名称一定要一样，写在stm32f10x_it.c文件里面，这样编译器才能根据名称找到中断服务程序，并把中断服务程序放在中断入口。
5. 中断服务程序最好是先确保产生了某个线中断
6. GPIO PC13 记得开AFIO时钟
7. 有没有包含头文件，除了.c文件，头文件有没有写对，应该在主函数里面声明的函数有没有声明。

```c
void NVIC_Config(void)
{
	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
	
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	
	NVIC_Init(&NVIC_InitStructure);
}

void EXTI_Key_Config(void)	
{
    GPIO_InitTypeDef GPIO_InitStructure;
    EXTI_InitTypeDef EXTI_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_AFIO, ENABLE); 
    
    NVIC_Config();
    
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_13;		//TX
    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;
    //GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
    //GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;		
    GPIO_Init(GPIOC, &GPIO_InitStructure);
    
    GPIO_EXTILineConfig(GPIO_PortSourceGPIOC, GPIO_PinSource13);
    
    EXTI_InitStructure.EXTI_Line = EXTI_Line13;			
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);
}

void EXTI15_10_IRQHandler(void)
{
    if(EXTI_GetITStatus(EXTI_Line13) == SET)
    {
    	SYSCLKConfig_STOP();	
    	
    	EXTI_ClearITPendingBit(EXTI_Line13);    //清除中断标志位
    }
}
```

- 原来向下，现在向上，分割线-----------------------------------------------------------------------------------------------------------------------------------------------

# APB

(Advanced Peripheral Bus)外围总线

# 使用引脚的配置

- 定义一个GPIO_InitTypeDef类型的结构体
- 开启外设的时钟（RCC的APB1或者APB2总线）
- 选择要控制的引脚
- 设置引脚的模式
- 设置引脚速率（原因未知）
- 初始化引脚
- 命令

```c
#include "stm32f10x.h"
#include <stdio.h>

void LED_GPIO_Config()
{
    GPIO_InitTypeDef GPIO_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC, ENABLE);//表示以下配置针对GPIOB和GPIOC
    
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_0;
    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;
    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;
    GPIO_Init(GPIOB, &GPIO_InitStructure);
    
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4|GPIO_Pin_3;
    GPIO_Init(GPIOC, &GPIO_InitStructure); //感觉应该是将最近一次配置的引脚信息写给GPIOC的吧
    
    GPIO_SetBits(GPIOB, GPIO_Pin_0);
    GPIO_SetBits(GPIOC, GPIO_Pin_4|GPIO_Pin_3);
}

//ST库函数提供两个可以用来对某位进行设置0和1的函数
void GPIO_SetBits(GPIOB, GPIO_Pin_0);

void GPIO_ResetBits(GPIOB, GPIO_Pin_0);
```

# LED灯的BSP文件

```c
#define ON 1;
#define OFF 0;

#define LED(a) if()
```

# 简单的延时函数

```c
void delay(__IO uint32_t nCount)
{
    for(; nCount>0; nCount--);
}
```

# 中断服务程序

- 这里举了个线中断的程序。首先需要检测是产生的什么中断，然后再作出反应，再清除相关寄存器的中断标志位。

```c
void EXIT15_10_IRQHandler()
{
    if(EXTI_GetITStatus(EXIT_Line13) != RESET)
    {
        EXTI_ClearITPendingBit(EXTI_Line13);
    }
}
```

# 串口

使用串口1 (USART1)步骤：

- 串口配置
- 串口中断配置
- 有必要则重定向c库函数（输出输入函数）
- 外设配置函数格式 void USART_Config(void);
- 中断向量控制器配置函数格式 void NVIC_Configuration(void);
- 程序示例

```c
void USART1_Config(void)	
{
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART1_InitStructure;
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_USART1, ENABLE); 
		
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_9;		//TX
    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;
    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;		
    GPIO_Init(GPIOA, &GPIO_InitStructure);
    
    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_10;		//RX
    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOA, &GPIO_InitStructure); 
	
    USART1_InitStructure.USART_BaudRate = 9600;
    USART1_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART1_InitStructure.USART_StopBits = USART_StopBits_1;
    USART1_InitStructure.USART_Parity = USART_Parity_No;
    USART1_InitStructure.USART_Mode = USART_Mode_Tx|USART_Mode_Rx;
    USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_Init(USART1, &USART1_InitStructure);
    USART_Cmd(USART1, ENABLE);
}

int fputc(int ch, FILE* fp)
{
	USART_SendData(USART1, (uint8_t)ch);		//TX
	
	while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET);
	
	return (ch);
}	

int fgetc(FILE* fp)
{
	while(USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);	
	
	return (int)USART_ReceiveData(USART1);			//RX
}
```

# 蓝牙的基本配置结构体

- 宏定义全部用大写形式，每个单词之间用下划线分割开

```c
#define BLTDEV_MAX_NUM 5

typedef struct
{
    uint16_t NAP;
    uint8_t LAP;
    uint32_t UAP;
}BLTaddr;

typedef struct
{
    //蓝牙数目
    uchar num;
    //配置蓝牙地址，数字模式
    BLTaddr addrInt[BLTDEV_MAX_NUM];
    //配置蓝牙地址，字符模式
    char BLKAddrChar[BLTDEV_MAX_NUM][50]；
    //这里使用了两种方式存储带两个属性的数据
    //蓝牙名称
    char BLKName[BLTDEV_MAX_NUM][50]；
}BLKDev;
```

## stdint.h

在函数中，尽量多使用uint8_t int8_t(uint16_t int16_t……)，多注意内存变量的分配。适合用多少位的就使用多少位。

# 停止模式

（使能HSE和PLL之后都会进行状态检测）（使用PLL作为系统时钟的同时要使能HSE时钟，因为PLL是由HSE提供的，在stm32f10x_rcc.c文件中也有说明）（配置电源处于低功耗模式即可进入睡眠模式，中断发生即可退出（退出后要唤醒时钟，可在中断服务程序中编写））

- 停止模式的进入

1. 使能电源管理时钟(RCC)
2. 配置电源管理的停止模式

```c
RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);

PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);
```

- 唤醒时钟的配置步骤：

1. 使能HSE时钟
2. 等待使能成功
3. 使能PLL时钟
4. 等待使能成功
5. 把PLL时钟设置为系统时钟
6. 等待设置成功

```c
void SystermClock_Config()
{
    RCC_HSEConfig(RCC_HSE_ON);
    while(~RCC_WaitForHSEStartUp());
    
    //很好奇在停止的模式中，PLL有关闭吗，为什么要ENABLE呢？（有的，被关了，但是频率什么都还存在，只是还未使能）
    RCC_PLLCmd(ENABLE);
    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY));
    
    //由于1.8V内核储存器关闭了，所以要重新设置系统电源
    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    while(RCC_GetSYSCLKSource() != 0x08);
}
```

```c
//楼上的修正版
void SYSCLKConfig_STOP()
{
    RCC_HSEConfig(RCC_HSE_ON);
    while(!RCC_WaitForHSEStartUp());
    
    RCC_PLLCmd(ENABLE);
    while(!RCC_GetFlagStatus(RCC_FLAG_PLLRDY));
    
    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
    while(RCC_GetSYSCLKSource() != 0x08);
}
```

```c
void SYSCLKConfig_STOP(void)
{
  ErrorStatus HSEStartUpStatus;

  RCC_HSEConfig(RCC_HSE_ON);

  HSEStartUpStatus = RCC_WaitForHSEStartUp();

  if(HSEStartUpStatus == SUCCESS)
  {
    RCC_PLLCmd(ENABLE);

    //为什么在这里使用RESET就可以（和RESET无关），但是用~就是上面的方法就行不通了呢？原因可能在于使用~和!是不同的，用~不可以，但是用!却可以
    //可以通过stm32f10x_rcc.c中查询得到SUCCESS是等于!ERROR，而不是~ERROR.
    //虽然0取反可以的得到1111……1111，但是1取反是1111……1110
    //也就是枚举变量里面存储的值是4字节的
    //所以结论就是~和!是不同的
    while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET);
		
    RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

    while(RCC_GetSYSCLKSource() != 0x08);
  }
	
}
```

# HSI

```c
void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
//该函数的校准值主要为了弥补不同电压和温度对内部HSI频率的影响
```

# SysTick

目前了解到的滴答定时器的作用就是用来延时（可以联系之前51的定时器使用）

- 延时使用步骤：

1. 配置滴答定时器（重装初值和关闭定时器）
2. 在延时函数中开启滴答定时器（让传入变量每次减1都是一次滴答中断）
3. 编写中断服务程序（在中断服务程序中队变量进行减一，而且必须保证你的中断服务程序所花费的时间要在你的两次滴答中断之间，否则会发生在执行中断服务程序的期间内会产生新的滴答中断）

```c
//使用static要注意的是这个变量改变的只是在此函数内
#define __IO _volatile
static __IO uint32_t SysTickTiming;

void SysTick_Init()
{
    if( SysTick_Config(SystemCoreClock/100000) )
    {
        while(1);
    }
    
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
}

void SysTick_Handler(void)
{
    TimingDelay_Decrement();
}

void TimingDelay_Decrement(void)
{
    SysTickTiming--;
}

void delay_us(uint32_t DelayTiming)
{
    SysTickTiming = DelayTiming;
    
    SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
    
    while(SysTickTiming != 0);
}
```

# LED

```c
//注意这里的0和1一定要根据电路图设计好
# define ON 0
#define OFF 1

//方式1
//带参宏这里不知道为什么要加分号，也不知道为什么else部分不用加分号？
#define LED1(a) if(a)\
        GPIO_SetBits(GPIOB, GPIO_Pin_0);\
        else\
        GPIO_ResetBits(GPIOB, GPIO_Pin_0)
        
#define LED2(a) if(a)\
        GPIO_SetBits(GPIOC, GPIO_Pin_4);\
        else\
        GPIO_ResetBits(GPIOC, GPIO_Pin_4)
        
#define LED3(a) if(a)\
        GPIO_SetBits(GPIOC, GPIO_Pin_3);\
        else\
        GPIO_ResetBits(GPIOC, GPIO_Pin_3)

//方式2
//这里后面也不知道为什么要加分号，明明引用的时候是：LED1_ON; 是有带分号的啊。
#define LED_ON(p, i) {p->BSRR=i;}
#define LED_OFF(p, i) {p->BRR=i;}
#define LED_TOGGLE(p, i) {p->BSRR ^= i;}

#define LED1_ON LED_ON(GPIOB, GPIO_Pin_0)
#define LED1_OFF LED_OFF(GPIOB, GPIO_Pin_0)
#define LED1_TOGGLE LED_TOGGLE(GPIOB, GPIO_Pin_0)

#define LED2_ON LED_ON(GPIOC, GPIO_Pin_4)
#define LED2_OFF LED_OFF(GPIOC, GPIO_Pin_4)
#define LED2_TOGGLE LED_TOGGLE(GPIOC, GPIO_Pin_4)

#define LED3_ON LED_ON(GPIOC, GPIO_Pin_3)
#define LED3_OFF LED_OFF(GPIOC, GPIO_Pin_3)
#define LED3_TOGGLE LED_TOGGLE(GPIOC, GPIO_Pin_3)
```

# 注意

这个文件的程序可能会有错误，使用需谨慎。



## 注意

- 使用keil的逻辑分析仪的时候，记得reset。
- 哦，原来那个使用定时器产生PWM波形匹配之前输出的是有效电平，匹配之后输出的是相反电平。在匹配的时候会进入中断服务程序，进入中断服务程序之后就可以修改下一阶段的有效电平占据的时间了。
- 使用LED PB0作为PWM波形的输出的时候一定要注意将引脚设置为复用推挽输出，而不是开漏输出，开漏输出使用不了PB0作为复用引脚的功能，而且输出的高电平过低。



# timestamp

时间戳是一个经加密之后形成的凭证文档。

# 双机通信

可以利用I2C或者蓝牙其他通信方式

- 主机（LED灯）：

1. 等待从机发送的高电平信号持续10ms，下降沿发送数据
2. 发送给从机应答信号
3. 准备接收从机发送的信号
4. 开始接收从机发送的数据
5. 将从机发来的数据同时显示在串口调试助手上
6. 开启主机RX接收中断，当接收到5ms的高电平的时候，停止接收。
7. 结束接收

- 从机（光敏电阻）：

1. 发送给主机起始信号（高电平持续10ms）
2. 接收主机发来的应答信号
3. 准备发送数据给主机
4. 开始发送数据
5. 数据结束发送的时候通过I2C(或者其他协议)发送一个5ms的信号给主机提示接收完毕
6. 结束发送

- 注意：

1. 本来打算使用I2C通信，最后发现用I2C没办法产生中断（或者说自己并不熟悉）来结束数据的传输，最后采用串口通信作为起始信号和终止信号的方式。
2. 串口发送有问题的时候可以考虑是否没有勾上use microLIB
3. 要注意头文件是否有声明要用到的函数
4. 使用串口中断的时候记得使能串口中断
5. 主机要配置按键线中断，延时一段时间后准备发送数据
6. 从机要配置串口接收中断，中断服务程序里面一直准备接收
7. 蓝牙串口和笔记本串口的转换波特率要转换对

# .h

stm32f10x.h 中包含#include "core_cm3.h" . #include "system_stm32f10x.h"两个文件

# BCD

(Binary Coded Decimal)二进制编码十进制

- stm32数据手册

1. 文中的缩写
2. 存储器和总线架构
3. CRC计算单元(CRC)
4. 电源控制(PWR)
5. 备份寄存器(BKP)
6. 复位和时钟控制(RCC)
7. 通用和复用功能I/O(GPIO/AFIO)
8. 中断和事件
9. DMA控制器(DMA)
10. 模拟/数字转换(ADC)
11. 数字/模拟转换(DAC)
12. 高级控制寄存器(TIM1和TIM8)
13. 通用定时器(TIMx)
14. 基本定时器(TIM6和TIM7)
15. 实时时钟(RTC)
16. 独立看门狗(IWDG)
17. 窗口看门狗(WWDG)
18. 灵活的静态存储控制器(FSMC)
19. SDIO接口(SDIO)
20. USB全速设备接口(USB)
21. 控制器局域网(bxCAN)
22. 串行外设接口(SPI)
23. I2C接口
24. 通用同步异步收发器(USART)
25. 器件电子签名
26. 调试支持(DBG)

# CortexM3

1. CorTex-M3概览
2. CorTex-M3基础
3. 指令集
4. 存储期系统
5. 实现CorTex-M3的全景概貌
6. 异常
7. NVIC与中断控制
8. 中断的具体行为
9. Cortex-M3的低层编程
10. 玩转异常系统
11. 编程进阶与系统行为
12. 存储保护单元MPU
13. 调试系统架构
14. 调试组件
15. 开始Cortex-M3的开发
16. ARM7应用程序移植到Cortex-M3
17. 使用GUN工具链开始Cortex-M3开发
18. KEIL RealView Microcontroller Development Kit(RVMDK)使用入门
19. ​
20. Cortex-M3指令小结
21. 16位Thumb指令及架构版本
22. Cortex-M3异常快速参考
23. 寄存器小结
24. Cortex-M3疑难解答

- 原来向下，现在向上，分割线-----------------------------------------------------------------------------------------------------------------------------------------------

# CMSIS

(Cortex Microcontroller Software Interface Standard)微处理器软件接口标准，是Cortex-M处理器系列与供应商无关的硬件抽象层。

# shortcut

使用F12可以快速定位到函数或者变量名定义的地方（也就是go to definiton）

# 

将外设声明为一个结构体，外设的基地址都用宏定义把它定义出来，将外设的基地址强制转换为指向结构体的指针，同样也采用宏定义的方法定义一个宏。然后通过宏来引用结构体的成员，也就是找到那个外设的基地址，接着就可以对外设的地址（寄存器）进行操作，实现相应的功能。

# ISP

(Internet Service Provider)互联网服务提供商

# BSP

(Board Support Pack)板级支持包。是主板硬件层和操作系统驱动层之间的一层。（一层软件，也就是一些封装了的函数，方便我们对底层寄存器的一些使用）

# GPIO

(General Purpose Input Output通用输入输出口，也就是扩展的IO口) stm32f10x_gpio.h 为外设的驱动文件，主要是操作一些IO口

# RCC

(Reset and Clock Control)复位和时钟配置寄存器。stm32f10x_gcc.h主要是与时钟相关的驱动文件

# 建立一个工程文件

按照template里面的模板来写

- 给user文件夹添加文件
- option for targets里面配置linking, output, define, include包含头文件的路径(include path), ulitities……

# GPIOA/GPIOB/GPIOC

指的是GPIO的不同的端口(PORT)，每个端口(GPIO_PIN)是16位（也就是有16个引脚可以作为输入输出使用）如果是引脚13的话为GPIO_PIN_13

# 

有三组不同的IO口，每个IO口操作七个寄存器(IDR（输入数据寄存器）, RCC（时钟配置寄存器）…… )

# PERIPH

指的是除了ARM核心设备之外的设备。如AD,DA,Timer和SPI等等。

# IDR

R(Input Data Resister)stm32的一个寄存器

# 片上资源

当使用片上资源的时候，要包含使用他们的头文件及源文件(bsp_exit.h)(bsp_key.h)(bsp_led.h)

# USART

(Universial Synchronous/Asynchronous Receiver/Transmitter)表示通用同步/异步串口接收/发送器

# USART串口1

包含有有数据寄存器DR(地址写法：USART1_DR_BASE)

# ADC

模数转换(也存在有数据寄存器)

# DMA

(Direct Memory Access)直接寄存器读取。即当使用串口和上位机通信的时候，可以独立运行，而不需要占用CPU的时间。 如果只有一个外设的话，DMA的优先级设置没有限制。但是如果使用多个外设，而外设又采用DMA传输的话，那么就需要指定优先级(DMA一共有四个优先级)。(DMA_Priority_VeryHigh. DMA_Priority_High. DMA_Priority_Medium. DMA_Priority_Low)

# FSMC

(Frexible Static Memory Controller)可变静态存储控制器

# NVIC

(Nested Vector Interrupt Controller)嵌套向量中断控制器。提供中断控制器，用于总体管理异常

# REF

(reference)参考标准的意思，在电路图中经常看到的`V_{ref}Vref`指的就是参考电压。这个参考电压不是真实的电压，而是作为真实电压比较的标准，然后，根据真实电压和这个电压的比较，从而对计算出输入值或者输出值。

# IWDG

(independent watch dog)独立看门狗

# bat

(battery)电池`V_{bat}Vbat`(voltage)表示电池电压

# LSE

(low speed external crystral)低速外部晶体

# BDCR

(Backup Domain Control Register)备份域控制寄存器

# RTC

(Real-Time Clock)实时时钟，应该是类似于51的那个实时时钟芯片DS1302

# `V_{CC}VCC` `V_{DD}VDD` `V_{SS}VSS`

`V_{CC}VCC` C表示Circuit, 即电路，也就是电路的电压。`V_{DD}VDD` D表示Device，即设备，也就是器件的电路。一般情况下，器件电压小于电路的电压。`V_{SS}VSS` S表示Series,即连接，也就是公共端，表示电路中的负极。

# BOOT0 BOOT1

（引导） TM32公司的启动程序分为三种模式。

- BOOTx BOOT0:程序从FLASH开始执行
- BOOT1 BOOT1:程序从内置SRAM开始执行
- BOOT0 BOOT1:程序从ISP（系统存储器）开始执行（这是一个ROM区，这部分存储区域在出厂时就被固定好了，是一个不可修改的区域）

# SWD

(Serial Wire Debug)串行线调试

# Jtag

(Joint Test Action Group)联合测试行动组织

# TMS

(Test Model Selection)测试模式选择。TMS,TCK,TDO,TDI分别为Jtag的四个接口

# NRF24L01

(RF:radio frequency辐射频率)NRF24L01为单片机射频收发接收器。射频的含义是辐射到空间的电磁频率。我们把具有远距离传输的高频电磁波称为射频。

# SDIO

(Secure Digit Input and Output Card)安全数字输入输出口。是在SD标准上定义的一种外接设备。

# HS008B

红外接收

# FWlib

(Firmware Library)固件库

# MISC

(M3 NVIC SysTickClock???)misc.h misc.c是与cortex M3内核NVIC和SysTick有关的驱动文件。

# 时钟

时钟是驱动时序逻辑电路（单片机或者微处理器本质上都是大规模时序逻辑电路）的动力

# 

制作：利用石英晶体的压电性（对石英晶体采用一定方式的切割，然后对其施加电压，会使石英晶体产生一定频率的振动）。然后又可以利用切割方式不同振动频率不同的特点使晶振可以批量生产。

# 

驱动单片机或者外设都需要时钟。

# 

时钟是一个脉冲信号发生器，CPU在进行完每次运算之后，在一定的时钟周期下将数据发送出去或者接收进来。因此时钟频率（晶振频率）可以表示CPU的一项性能指标。

# 

时钟发生器提供给PC机连续的脉冲信号，而这些脉冲信号会使用芯片（由众多晶体管组成）内晶体管的状态发生变化（数字逻辑电路中晶体管作为开关），从而让CPU执行一定的命令。但是如果时钟频率过高，可能会使晶体管的状态来不及发生变化，导致死锁或者随机误操作现象的发生。也因为这样，所以每一样器件都有它的极限频率，所以STM32外设要分频也是这个道理。

# stm32的IO口模式选择

- 模拟输出：传统模式。
- 上拉输入：利用上拉电阻接电源。
- 下拉输入：利用下拉电阻接地。
- 浮空输入：输入端接的既不是高电平也不是低电平，输入状态为高阻态，即未知。
- 推挽输出：可以输出高低电平（两个三极管）。
- 开漏输出：输出低电平，输出高电平要接上拉电阻，上拉能力弱。
- 推挽输出和开漏输出的区别：推挽输出和开漏输出输出低电平的时候都是接地，但是输出高电平的时候，推挽输出可以输出和电源电压一样的电压，开漏输出输出的电压比电源电压低（所以在继电器使用方面，如果接的5伏电压，那么使用开漏输出可以降低到3.3伏）。
- ​
- 复用推挽输出：GPIO口作为第二功能使用。
- 复用开漏输出：GPIO口作为第二功能使用。

# stm32的外设

- 数模转换(ADC)
- 备份域(BKP)
- can总线传输（恶劣环境远距离传输）(CAN)
- 外部中断(EXTI)
- 闪存(FLASH)
- 通用IO口(GPIO)
- I2C通信(I2C)
- 独立看门狗(IWDG)
- 复位和时钟控制(RCC)
- SPI通信(SPI)
- 串口通信(USART)

# FPU

(floating point uint)浮点运算单元

# stm头文件源文件的使用

- startup_stm32f10x_hd.s 汇编启动文件
- stm32f10x.c
- stm32f10x.h
- misc.c 这个文件是用来配置与中断有关的初始化之类的
- stm32f10x_it.c 存放中断服务程序
- stm32f10x_it.h 存放中断服务程序
- stm32f10x_conf.h
- stm32f10x_gpio.c 有关外设的驱动文件（板级支持包是基于这个文件写的）
- stm32f10x_exti.h
- stm32f10x_rcc.c 复位及时钟控制
- core_cm3.c 与内核有关的源文件
- core_cm3.h 与内核有关的头文件

# 开发

在开发中，stm32f10x_gpio.c文件用得非常多，时钟树，引脚图和这个文件几乎在用

# IRQ

(interrupt request)中断请求

# 复用与重映射

- 复用：GPIO口用作AFIO口(Alternate function IO)，需要配置这个GPIO口的第二功能
- 重映射：把原来属于A引脚的复用功能映射到B引脚上使用。（也就是使得B引脚也可以通过配置然后进入本来只能通过A引脚才能进入的地址）

# __WFI和__WFE的区别

WFI是指中断主动向CPU请求中断，而WFE是指把相应的事件标志位置1，需要CPU去查询相应的寄存器。

# stm32有16种中断线

- 汇编注释的写法是加个分号
- EXTI0_IRQHandler
- EXTI1_IRQHandler
- EXTI2_IRQHandler
- EXTI3_IRQHandler
- EXTI4_IRQHandler
- EXIT9_5_IRQHandler
- EXIT15_10_IRQHandler

# 电源

- 睡眠实验：程序正常运行，等待睡眠，触发中断，执行中断服务程序，回到程序继续执行。

# 重定向c库函数

重定向c库函数指的是将原来的c库函数给重新指向新的地方。比如串口中将fputc()函数重定向到串口中，那么所有基于fputc()的函数，比如printf()函数就从向控制台窗口被重定向到串口输出中。

# 中断

中断可以由上升沿，下降沿，上升下降沿触发（需要配置）。 其中，按键产生中断是最简单的。还有串口也可以产生中断，通过对USART的中断模式的选择可以选择通过哪一种方式来触发中断。

# PLL

(Phase Locked Loop)锁相回路/锁相环。用来统一整合时序信号，使内存可以保存资料。许多电子设备要正常工作，必须使外部输入信号和内部振荡脉冲信号相同，锁相环的作用就在于此。

# stm32存在位段，位带别名区

在寻址空间的另一个地方，取一个别名区，从这个地址开始，每一个字（32bits）就对应到SRAM或者IO中的一位。

# DeInit()

(Defaults Init)和这个函数有关的是恢复默认值用的，一般不用

# AT模式

好像进入蓝牙的AT模式，可以设置很多东西 比如设置蓝牙串口通信的波特率为9600，1位停止位，没有校验位：AT+USAT=9600,0,0

- HC-05和HC-06不同，它进入AT模式，可以通过按下模块上方的小黑点按钮，当闪烁灯慢闪的时候，就表示进入AT模式。

# BLT

(Blue Tooth)蓝牙

# 封装中的设定某位

在stm32的自带函数中，比如stm32f10x_rcc.c中对一个外设的时钟使能，它用的方法是先使用宏定义外设的时钟使能位（通过地址映射到宏定义中），然后将与电源有关的寄存器（每个寄存器有32位）也使用宏定义起来。之后就通过if……else语句进行相应操作。

```
if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph; //即RCC_APB2Periph(时钟使能位)为1（这是一个uint32的值），与上整个寄存器的值就等于某位改变，其他位置0
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;    //时钟使能位置0（取反），其他不变
  }
```

# USART_SR

(Univeral Synchronous/Asynchronous Receiver/Transmitter_Status Register)通用同步异步收发状态寄存器。它里面的TXD(transmit data register empty)和TC(transmit complete)的区别在TXD是判断数据寄存器的数据发送到移位寄存器是否发送完毕，而TC是判断数据移位寄存器中的数据是否发送给上位机完毕。

# stm32f10x_h

这个头文件里面定义了stm32外设的所有寄存器（使用typedef结构体的形式）

# 字符串

字符串不是C的某种存储类型（整型，浮点型，数组，指针……），所以在C语言中使用数组来存储字符串。那么如何如何判断一个数组的大小或者如何知道它什么时候结束呢？C中使用空字符('\0')(ANSIS码值为0)来作为数组结束的标志（初始化字符串的时候系统会自动加上去的）。另外，C中每个字符存储在数组中的每个存储单元中，使用的是char型数组，所以每个存储单元为一个字节。

# volatile

C里面的一个关键字，修饰数据类型用的，主要是用来禁止C编译器对变量的优化，因为编译器有可能会将变量的值存入某个寄存器中（副本）（因为程序执行的时候，读取寄存器的值会比读取RAM快），但是，如果这个变量在中断服务程序中被改变的话，中断服务没办法对对寄存器的值进行修改。如果加上volatile，那么程序读取的变量的值就会从地址处出读出，即每次都能读取到变量真正的值。

# 全双工

全双工的意思是收发可同时进行

# RSSI

(Receive Signal Strength Indication)接收的信号强度。主要运用在无线技术中，如广播，蓝牙等。

# 字库

由于英文的字库比较小，所以我们可以把程序放在flash里面，但是由于中文的字库太大，一般有几百K（M3内部的flash有512K）,所以我们把中文的字库放到了SD卡里面。

# OV7725

一帧表示一幅图像，一般每秒超过24帧则人眼无法分辨出来。

# DS18B20

小数部分最多只能表示1位

# 2.4G无线模块的传输

（使用的是NRF24L01芯片）

- 特点：数据传输不大（小容量的数据可以，但是不可以传送视频这些容量大的数据），穿透能力弱
- 串口数据传输，RS485数据传输，区别于RS232。
- RS485是一种接口标准，但是只是规定了接口的电气标准，简单说是物理层的一个标准。它没有对接口插件电缆及传输协议作出规定，所以我们可以在串口标准协议下使用各种协议进行设备之间的通信及设备控制。
- 主机要烧写入程序，从机也要烧写入程序

# RS485电平

（使用芯片：SN75LBC184） RS485芯片可以将TTL电平转换为RS485电平

# LAN

(Local Area Network)局域网。是指在一个特定的区域内，将计算机，外部设备和数据库等连接在一起而形成的一个计算机通信网络。区别于WAN(Wide Area Network)广域网

# 以太网

- 如果要在其他局域网内控制stm32（在另一个局域网里），那么他们的网关应该是相同的。
- 每台电脑都有自己的ip，单片机也可以设置一个单片机自己的ip地址。
- 每个路由器都有自己的一个网关，当笔记本连接到无线局域网的时候，就会得到一个本机的ip,也可以通过cmd找到网关的数值。
- 每台电脑的ip都应该是不一样的，就像我们设置单片机的ip的时候，不能设置和其他人的笔记本具有相同的ip。否则在相同的局域网内，当你将数据ping上去的时候，会发生，当某一台电脑想要控制单片机的时候，却发送数据给其他的具有相同ip的笔记本。
- 通过DOS模式可以远程登陆某一个ip地址，比如，可以远程登陆单片机的ip，然后远程控制单片机。还可以通过http网站上输入ip进行操作。

# 以太网和局域网的区别

局域网讲的只是一个网络的规模，而以太网说的是局域网最通用的一种通信协议标准。

# ping

- ping指的是向一个网址发送数据测试包，判断对方是否有响应并统计响应时间，以此来测试网络。

# OTG

(On-The-G0)是一种可以在设备或者移动设备之间通过USB线进行数据传输的技术。

- 使用USB进行数据传输具有两种方式：

1. 有可以充当host（主机）的设备，比如PC。ISO板子上的USB接口只能充当从机使用（stm32f10x系列不支持OTG技术，stm32f20，stm32f40系列有支持）。
2. 支持OTG技术。

# 红外遥控

- 理论上，红外遥控的接收角度是15°，距离是15米。
- 不同的红外设备（控制电视的，控制空调的）具有不同的波形，而不同的波形是不同的红外设备一开始就固定好了的（就好像已经集成好I2C通信的设备一样），并使用这个波形作为数据传输的方式。而红外接收就必须先了解到红外遥控设备的数据发送方式，并进行具体的解码，然后就可以得到是红外遥控上哪一个按键被按下了，并根据按下的按键执行相应的操作。

# AHB和APB

(Advanced High Performance Bus)系统总线和(Advanced Peripher Bus)外围总线

# EXTI

外部中断的触发有两种类型（模式），即中断触发和事件触发。(Pulse和Pending)

# stm32f10x_rcc.c

1. HSE
2. HSI
3. PLL
4. SystermClock
5. HCLK
6. PCLK
7. IT
8. USBClock
9. OTGClock
10. ADCClock
11. I2CClock
12. LSE
13. LSI
14. RTC

```
15. GetCocksFreq();
```

1. AHB
2. APB
3. BKR
4. CSS(CLock Security Systerm)
5. MCO(Main Clock Output)

```
20. GetFlagStatus();
21. CLearFlag();
22. GetITStatus();
23. ClearITPendingBit()；
```

# timing

定时。time的ing形式

# core_cm3.h

这个函数里面写有与NVIC和SysTick有关的函数

# stm32f10x.h

这个文件里面有关于配置里面两个宏定义的信息。

- USE_STDPERIPH_DRIVER（在第8296-8298行中，有包含stm32f10x_conf.h） :如果定义了这个宏，那么你可以使用st公司为你编写的32库函数，但是如果你没有定义的话，只能自己去操作底层的外设寄存器。
- 这个头文件所包含的头文件：

1. \#include "core_cm3.h"
2. \#include "systerm_stm32f10x.h"
3. \#include <stdint.h>
4. \#include "stm32f10x_conf.h"

# 电源控制

三种电源模式：睡眠模式，停止模式，待机模式

1. 电源管理电源： i. VDDA供电区域：外设的电源（温度传感器，AD转换器，复位电路，PLL(Phase Locked Loop)） ii. VDD供电区域：待机电路（唤醒逻辑：IWDG）（带电压调节器） iii. 1.8V核心电源：内核存储器供电区域（内置数字外设） iv. 后备电源区域：带后备寄存器
2. 电源模块： i. 睡眠模式：内核时钟关闭，外设时钟不关闭（进入方式：__WFI(); __WFE():）（唤醒方式：任一中断或者唤醒事件（目前还没用过事件唤醒）） ii. 停止模式：所有时钟都关闭（进入方式：PDDS位和LPDS位+SLEEPDEEP位+ __WFI();或__WFE(); 唤醒方式：任一外部中断（在外部中断寄存器中配置））。由于执行了停止模式，所有的时钟都停止了，所以，醒来的时候要记得配置系统时钟，72MHz，如果还要使用外设记得配置外设的时钟啊。 iii. 待机模式：所有时钟关闭+1.8V核心电源也关闭（进入方式：PDDS位+SLEEPDEEP位+ __WFI();或__WFE(): 唤醒方式：WKUP上升沿；RTC闹钟事件；NRST外部复位；IWDG复位）
3. 电压调节器 （一些模式的选择需要配置电压调节器） i. 运转模式：以正常功耗提供1.8V电源（内存，内核，外设） ii. 停止模式：以低功耗提供1.8V电源（保证寄存器和SRAM和内容不丢失） iii. 待机模式：不供电。除了备份电路和备份域内容外，寄存器和SRAM的内容全部丢失。



## OV7725

## V-sync

(Vertical Sync)垂直同步



## MEMS

- 里面集成了一个陀螺仪和一个加速度传感器。陀螺仪可以用来测量角速度，然后通过对时间积分可以求出角度，即偏航角，横滚角和俯倾角。角速度传感器主要通过力传感器得到三轴的加速度，注意这里的加速度是静止时候的重力加速度的分加速度，然后利用分加速度与重力加速度的夹角关系可以得出静止时候的三个角度，可以对由陀螺仪带来的误差进行校准。但是加速度传感器有一个缺陷，就是无法检测Yaw角。
- 角速度指的是绕轴旋转的速度，那它绕轴旋转的速度是怎么转换为角度的啊？角速度是和陀螺仪有关的。（拿个传感器试一下就知道了）
- 里面有一个DMP(Digital Motion Processor)数字运动处理器，它可以对采集到的角速度，加速度进行姿滤波，融合处理，直接向主控机输出姿态融合之后的数据，可以大幅度降低主控机的运算量，频率为200Hz。
- 六轴在XDA,XLK加上HAM883磁场传感器，就实现九轴。
- I2C有七位地址和八位地址的区别。六轴传感器是用的七位地址，接地地址为0x68,接VCC的话地址为0x69。写地址左移一位加一就是读地址。
- 电路板运行的时候不要用手去触摸，如果用手去触摸，可能会产生静电影响。
- MPU6050的设备I2C地址和stm32上面的I2C设备地址是不一样的，MPU6050的地址是固定好的，而stm32上面的地址只要保证不和MPU6050z一样就可以了。



## RCC

- HCLK时钟用于AHB bus,core, memory和DMA；PCLK1时钟用于APB1 periphrals；PCLK2用于APB2 periphrals.
- 一般情况下程序的HCLK采用的是系统时钟

```c
RCC_HCLKConfig(RCC_SYSTEM_Div1);
RCC_PCLK1Config(RCC_HCLK_Div1);
RCC_PCLK2Config(RCC_HCLK_Div2);
```



# TFT触摸屏

- (Thin Film Tube)薄膜晶体管
- 彩屏显示原理：每一个像素点集成了一定数量的有色晶体管（由于晶体管的物理性质，其不可无限大），通过晶体管颜色的叠加使得每一个像素点可以发出多种颜色的光（比如RGB565就表示每个像素点采用两个字节的数据存储信息，通过AD转换，将输入的二进制信息转换为电压的信息，相应的电压会使晶体管表现出不同的状态，从而达到控制屏幕上色彩变化的目的）。
- 触摸屏的使用方法：建立二维坐标，通过对触摸点的位置的获取与判断实现相应的功能
- 优点：和普通黑白显示屏对比，可以实现彩色输出，触摸屏还可以容易地指定屏幕上特定功能块，而不需要像非触摸屏一样需要多余的按键。
- 缺点：耗电（像素集成度高）。如果对屏幕上像素点捕捉的条件没有写好的话，很容易出现在一个屏幕上触屏会触发另一个界面的功能（可以通过设置标志位来解决）。

# MPU6050

是一种姿势传感器，通过I2C通信可以得到六个数据（三轴加速度的AD值和三轴角速度的AD值），通过姿态融合算法可以得到三个角度（pitch(俯倾角)，roll角（滚转角），yaw（偏航角）），通过这三个角度可以判断一个三位空间内质点的运动方向。 它采用的不是固定的直角坐标系，而是随运动位置变化的直角坐标系。

### 笛卡尔坐标系

- 是指直角坐标系和斜角坐标系的统称

### 三轴旋转矩阵

- 角定义：
  - 绕x轴旋转 θx 是 roll 角。
  - 绕 y-轴旋转 θy 是 pitch 角。
  - 绕 z-轴旋转 θz 是 yaw 角。
- 在飞行动力学中，roll, pitch 和 yaw 角通常分别采用符号 γ, α, 和 β;但是为了避免混淆于欧拉角可以使用符号 θx, θy 和 θz。
- 任何 3 维旋转矩阵 都可以用这三个角 θx, θy, 和 θz 来刻画，并且可以表示为 roll, pitch 和 yaw 矩阵的乘积

### 陀螺仪

- 陀螺仪是一种反重力的仪器，在飞行器和平衡小车上面有使用。

# 3.3V继电器

- 光耦隔离：采用光耦器（由发光二极管和光敏三极管组成）进行隔离的一种方法，主要是对电路的一种保护作用（特别是在同时存在高压电路和低压电路中）。

# HC-SR04超声波感应器

- trig是控制端，echo是接收端



# CMSIS

(Cortex Microcontroller Software Interface Standard)微处理器软件接口标准，是Cortex-M处理器系列与供应商无关的硬件抽象层。

# shortcut

使用F12可以快速定位到函数或者变量名定义的地方（也就是go to definiton）

# 

将外设声明为一个结构体，外设的基地址都用宏定义把它定义出来，将外设的基地址强制转换为指向结构体的指针，同样也采用宏定义的方法定义一个宏。然后通过宏来引用结构体的成员，也就是找到那个外设的基地址，接着就可以对外设的地址（寄存器）进行操作，实现相应的功能。

# ISP

(Internet Service Provider)互联网服务提供商

# BSP

(Board Support Pack)板级支持包。是主板硬件层和操作系统驱动层之间的一层。（一层软件，也就是一些封装了的函数，方便我们对底层寄存器的一些使用）

# GPIO

(General Purpose Input Output通用输入输出口，也就是扩展的IO口) stm32f10x_gpio.h 为外设的驱动文件，主要是操作一些IO口

# RCC

(Reset and Clock Control)复位和时钟配置寄存器。stm32f10x_gcc.h主要是与时钟相关的驱动文件

# 建立一个工程文件

按照template里面的模板来写

- 给user文件夹添加文件
- option for targets里面配置linking, output, define, include包含头文件的路径(include path), ulitities……

# GPIOA/GPIOB/GPIOC

指的是GPIO的不同的端口(PORT)，每个端口(GPIO_PIN)是16位（也就是有16个引脚可以作为输入输出使用）如果是引脚13的话为GPIO_PIN_13

# 

有三组不同的IO口，每个IO口操作七个寄存器(IDR（输入数据寄存器）, RCC（时钟配置寄存器）…… )

# PERIPH

指的是除了ARM核心设备之外的设备。如AD,DA,Timer和SPI等等。

# IDR

R(Input Data Resister)stm32的一个寄存器

# 片上资源

当使用片上资源的时候，要包含使用他们的头文件及源文件(bsp_exit.h)(bsp_key.h)(bsp_led.h)

# USART

(Universial Synchronous/Asynchronous Receiver/Transmitter)表示通用同步/异步串口接收/发送器

# USART串口1

包含有有数据寄存器DR(地址写法：USART1_DR_BASE)

# ADC

模数转换(也存在有数据寄存器)

# DMA

(Direct Memory Access)直接寄存器读取。即当使用串口和上位机通信的时候，可以独立运行，而不需要占用CPU的时间。 如果只有一个外设的话，DMA的优先级设置没有限制。但是如果使用多个外设，而外设又采用DMA传输的话，那么就需要指定优先级(DMA一共有四个优先级)。(DMA_Priority_VeryHigh. DMA_Priority_High. DMA_Priority_Medium. DMA_Priority_Low)

# FSMC

(Frexible Static Memory Controller)可变静态存储控制器

# NVIC

(Nested Vector Interrupt Controller)嵌套向量中断控制器。提供中断控制器，用于总体管理异常

# REF

(reference)参考标准的意思，在电路图中经常看到的`V_{ref}Vref`指的就是参考电压。这个参考电压不是真实的电压，而是作为真实电压比较的标准，然后，根据真实电压和这个电压的比较，从而对计算出输入值或者输出值。

# IWDG

(independent watch dog)独立看门狗

# bat

(battery)电池`V_{bat}Vbat`(voltage)表示电池电压

# LSE

(low speed external crystral)低速外部晶体

# BDCR

(Backup Domain Control Register)备份域控制寄存器

# RTC

(Real-Time Clock)实时时钟，应该是类似于51的那个实时时钟芯片DS1302

# `V_{CC}VCC` `V_{DD}VDD` `V_{SS}VSS`

`V_{CC}VCC` C表示Circuit, 即电路，也就是电路的电压。`V_{DD}VDD` D表示Device，即设备，也就是器件的电路。一般情况下，器件电压小于电路的电压。`V_{SS}VSS` S表示Series,即连接，也就是公共端，表示电路中的负极。

# BOOT0 BOOT1

（引导） TM32公司的启动程序分为三种模式。

- BOOTx BOOT0:程序从FLASH开始执行
- BOOT1 BOOT1:程序从内置SRAM开始执行
- BOOT0 BOOT1:程序从ISP（系统存储器）开始执行（这是一个ROM区，这部分存储区域在出厂时就被固定好了，是一个不可修改的区域）

# SWD

(Serial Wire Debug)串行线调试

# Jtag

(Joint Test Action Group)联合测试行动组织

# TMS

(Test Model Selection)测试模式选择。TMS,TCK,TDO,TDI分别为Jtag的四个接口

# NRF24L01

(RF:radio frequency辐射频率)NRF24L01为单片机射频收发接收器。射频的含义是辐射到空间的电磁频率。我们把具有远距离传输的高频电磁波称为射频。

# SDIO

(Secure Digit Input and Output Card)安全数字输入输出口。是在SD标准上定义的一种外接设备。

# HS008B

红外接收

# FWlib

(Firmware Library)固件库

# MISC

misc.h misc.c是与cortex M3内核NVIC和SysTick有关的驱动文件。

# 时钟

时钟是驱动时序逻辑电路（单片机或者微处理器本质上都是大规模时序逻辑电路）的动力

# 

制作：利用石英晶体的压电性（对石英晶体采用一定方式的切割，然后对其施加电压，会使石英晶体产生一定频率的振动）。然后又可以利用切割方式不同振动频率不同的特点使晶振可以批量生产。

# 

驱动单片机或者外设都需要时钟。

# 

时钟是一个脉冲信号发生器，CPU在进行完每次运算之后，在一定的时钟周期下将数据发送出去或者接收进来。因此时钟频率（晶振频率）可以表示CPU的一项性能指标。

# 

时钟发生器提供给PC机连续的脉冲信号，而这些脉冲信号会使用芯片（由众多晶体管组成）内晶体管的状态发生变化（数字逻辑电路中晶体管作为开关），从而让CPU执行一定的命令。但是如果时钟频率过高，可能会使晶体管的状态来不及发生变化，导致死锁或者随机误操作现象的发生。也因为这样，所以每一样器件都有它的极限频率，所以STM32外设要分频也是这个道理。

# stm32的IO口模式选择

- 模拟输出：传统模式。
- 上拉输入：利用上拉电阻接电源。
- 下拉输入：利用下拉电阻接地。
- 浮空输入：输入端接的既不是高电平也不是低电平，输入状态为高阻态，即未知。
- 推挽输出：可以输出高低电平（两个三极管）。
- 开漏输出：输出低电平，输出高电平要接上拉电阻，上拉能力弱。
- 复用推挽输出：GPIO口作为第二功能使用。
- 复用开漏输出：GPIO口作为第二功能使用。

# stm32的外设

- 数模转换(ADC)
- 备份域(BKP)
- can总线传输（恶劣环境远距离传输）(CAN)
- 外部中断(EXTI)
- 闪存(FLASH)
- 通用IO口(GPIO)
- I2C通信(I2C)
- 独立看门狗(IWDG)
- 复位和时钟控制(RCC)
- SPI通信(SPI)
- 串口通信(USART)

# LDE_GPIO_Config()

LED_GPIO_Config( )



# timestamp

时间戳是一个经加密之后形成的凭证文档。

# 双机通信

可以利用I2C或者蓝牙其他通信方式

- 主机（LED灯）：

1. 等待从机发送的高电平信号持续10ms，下降沿发送数据
2. 发送给从机应答信号
3. 准备接收从机发送的信号
4. 开始接收从机发送的数据
5. 将从机发来的数据同时显示在串口调试助手上
6. 开启主机RX接收中断，当接收到5ms的高电平的时候，停止接收。
7. 结束接收

- 从机（光敏电阻）：

1. 发送给主机起始信号（高电平持续10ms）
2. 接收主机发来的应答信号
3. 准备发送数据给主机
4. 开始发送数据
5. 数据结束发送的时候通过I2C(或者其他协议)发送一个5ms的信号给主机提示接收完毕
6. 结束发送

- 注意：

1. 本来打算使用I2C通信，最后发现用I2C没办法产生中断（或者说自己并不熟悉）来结束数据的传输，最后采用串口通信作为起始信号和终止信号的方式。
2. 串口发送有问题的时候可以考虑是否没有勾上use microLIB
3. 要注意头文件是否有声明要用到的函数
4. 使用串口中断的时候记得使能串口中断
5. 主机要配置按键线中断，延时一段时间后准备发送数据
6. 从机要配置串口接收中断，中断服务程序里面一直准备接收
7. 蓝牙串口和笔记本串口的转换波特率要转换对

# .h

stm32f10x.h 中包含#include "core_cm3.h" . #include "system_stm32f10x.h"两个文件

# BCD

(Binary Coded Decimal)二进制编码十进制

- stm32数据手册

1. 文中的缩写
2. 存储器和总线架构
3. CRC计算单元(CRC)
4. 电源控制(PWR)
5. 备份寄存器(BKP)
6. 复位和时钟控制(RCC)
7. 通用和复用功能I/O(GPIO/AFIO)
8. 中断和事件
9. DMA控制器(DMA)
10. 模拟/数字转换(ADC)
11. 数字/模拟转换(DAC)
12. 高级控制寄存器(TIM1和TIM8)
13. 通用定时器(TIMx)
14. 基本定时器(TIM6和TIM7)
15. 实时时钟(RTC)
16. 独立看门狗(IWDG)
17. 窗口看门狗(WWDG)
18. 灵活的静态存储控制器(FSMC)
19. SDIO接口(SDIO)
20. USB全速设备接口(USB)
21. 控制器局域网(bxCAN)
22. 串行外设接口(SPI)
23. I2C接口
24. 通用同步异步收发器(USART)
25. 器件电子签名
26. 调试支持(DBG)

# CortexM3

1. CorTex-M3概览
2. CorTex-M3基础
3. 指令集
4. 存储期系统
5. 实现CorTex-M3的全景概貌
6. 异常
7. NVIC与中断控制
8. 中断的具体行为
9. Cortex-M3的低层编程
10. 玩转异常系统
11. 编程进阶与系统行为
12. 存储保护单元MPU
13. 调试系统架构
14. 调试组件
15. 开始Cortex-M3的开发
16. ARM7应用程序移植到Cortex-M3
17. 使用GUN工具链开始Cortex-M3开发
18. KEIL RealView Microcontroller Development Kit(RVMDK)使用入门
19. ​
20. Cortex-M3指令小结
21. 16位Thumb指令及架构版本
22. Cortex-M3异常快速参考
23. 寄存器小结
24. Cortex-M3疑难解答

- 原来向下，现在向上，分割线-----------------------------------------------------------------------------------------------------------------------------------------------


- # CMSIS

  (Cortex Microcontroller Software Interface Standard)微处理器软件接口标准，是Cortex-M处理器系列与供应商无关的硬件抽象层。

  # shortcut

  使用F12可以快速定位到函数或者变量名定义的地方（也就是go to definiton）

  # 

  将外设声明为一个结构体，外设的基地址都用宏定义把它定义出来，将外设的基地址强制转换为指向结构体的指针，同样也采用宏定义的方法定义一个宏。然后通过宏来引用结构体的成员，也就是找到那个外设的基地址，接着就可以对外设的地址（寄存器）进行操作，实现相应的功能。

  # ISP

  (Internet Service Provider)互联网服务提供商

  # BSP

  (Board Support Pack)板级支持包。是主板硬件层和操作系统驱动层之间的一层。（一层软件，也就是一些封装了的函数，方便我们对底层寄存器的一些使用）

  # GPIO

  (General Purpose Input Output通用输入输出口，也就是扩展的IO口) stm32f10x_gpio.h 为外设的驱动文件，主要是操作一些IO口

  # RCC

  (Reset and Clock Control)复位和时钟配置寄存器。stm32f10x_gcc.h主要是与时钟相关的驱动文件

  # 建立一个工程文件

  按照template里面的模板来写

  - 给user文件夹添加文件
  - option for targets里面配置linking, output, define, include包含头文件的路径(include path), ulitities……

  # GPIOA/GPIOB/GPIOC

  指的是GPIO的不同的端口(PORT)，每个端口(GPIO_PIN)是16位（也就是有16个引脚可以作为输入输出使用）如果是引脚13的话为GPIO_PIN_13

  # 

  有三组不同的IO口，每个IO口操作七个寄存器(IDR（输入数据寄存器）, RCC（时钟配置寄存器）…… )

  # PERIPH

  指的是除了ARM核心设备之外的设备。如AD,DA,Timer和SPI等等。

  # IDR

  R(Input Data Resister)stm32的一个寄存器

  # 片上资源

  当使用片上资源的时候，要包含使用他们的头文件及源文件(bsp_exit.h)(bsp_key.h)(bsp_led.h)

  # USART

  (Universial Synchronous/Asynchronous Receiver/Transmitter)表示通用同步/异步串口接收/发送器

  # USART串口1

  包含有有数据寄存器DR(地址写法：USART1_DR_BASE)

  # ADC

  模数转换(也存在有数据寄存器)

  # DMA

  (Direct Memory Access)直接寄存器读取。即当使用串口和上位机通信的时候，可以独立运行，而不需要占用CPU的时间。 如果只有一个外设的话，DMA的优先级设置没有限制。但是如果使用多个外设，而外设又采用DMA传输的话，那么就需要指定优先级(DMA一共有四个优先级)。(DMA_Priority_VeryHigh. DMA_Priority_High. DMA_Priority_Medium. DMA_Priority_Low)

  # FSMC

  (Frexible Static Memory Controller)可变静态存储控制器

  # NVIC

  (Nested Vector Interrupt Controller)嵌套向量中断控制器。提供中断控制器，用于总体管理异常

  # REF

  (reference)参考标准的意思，在电路图中经常看到的`V_{ref}Vref`指的就是参考电压。这个参考电压不是真实的电压，而是作为真实电压比较的标准，然后，根据真实电压和这个电压的比较，从而对计算出输入值或者输出值。

  # IWDG

  (independent watch dog)独立看门狗

  # bat

  (battery)电池`V_{bat}Vbat`(voltage)表示电池电压

  # LSE

  (low speed external crystral)低速外部晶体

  # BDCR

  (Backup Domain Control Register)备份域控制寄存器

  # RTC

  (Real-Time Clock)实时时钟，应该是类似于51的那个实时时钟芯片DS1302

  # `V_{CC}VCC` `V_{DD}VDD` `V_{SS}VSS`

  `V_{CC}VCC` C表示Circuit, 即电路，也就是电路的电压。`V_{DD}VDD` D表示Device，即设备，也就是器件的电路。一般情况下，器件电压小于电路的电压。`V_{SS}VSS` S表示Series,即连接，也就是公共端，表示电路中的负极。

  # BOOT0 BOOT1

  （引导） TM32公司的启动程序分为三种模式。

  - BOOTx BOOT0:程序从FLASH开始执行
  - BOOT1 BOOT1:程序从内置SRAM开始执行
  - BOOT0 BOOT1:程序从ISP（系统存储器）开始执行（这是一个ROM区，这部分存储区域在出厂时就被固定好了，是一个不可修改的区域）

  # SWD

  (Serial Wire Debug)串行线调试

  # Jtag

  (Joint Test Action Group)联合测试行动组织

  # TMS

  (Test Model Selection)测试模式选择。TMS,TCK,TDO,TDI分别为Jtag的四个接口

  # NRF24L01

  (RF:radio frequency辐射频率)NRF24L01为单片机射频收发接收器。射频的含义是辐射到空间的电磁频率。我们把具有远距离传输的高频电磁波称为射频。

  # SDIO

  (Secure Digit Input and Output Card)安全数字输入输出口。是在SD标准上定义的一种外接设备。

  # HS008B

  红外接收

  # FWlib

  (Firmware Library)固件库

  # MISC

  misc.h misc.c是与cortex M3内核NVIC和SysTick有关的驱动文件。

  # 时钟

  时钟是驱动时序逻辑电路（单片机或者微处理器本质上都是大规模时序逻辑电路）的动力

  # 

  制作：利用石英晶体的压电性（对石英晶体采用一定方式的切割，然后对其施加电压，会使石英晶体产生一定频率的振动）。然后又可以利用切割方式不同振动频率不同的特点使晶振可以批量生产。

  # 

  驱动单片机或者外设都需要时钟。

  # 

  时钟是一个脉冲信号发生器，CPU在进行完每次运算之后，在一定的时钟周期下将数据发送出去或者接收进来。因此时钟频率（晶振频率）可以表示CPU的一项性能指标。

  # 

  时钟发生器提供给PC机连续的脉冲信号，而这些脉冲信号会使用芯片（由众多晶体管组成）内晶体管的状态发生变化（数字逻辑电路中晶体管作为开关），从而让CPU执行一定的命令。但是如果时钟频率过高，可能会使晶体管的状态来不及发生变化，导致死锁或者随机误操作现象的发生。也因为这样，所以每一样器件都有它的极限频率，所以STM32外设要分频也是这个道理。

  # stm32的IO口模式选择

  - 模拟输出：传统模式。
  - 上拉输入：利用上拉电阻接电源。
  - 下拉输入：利用下拉电阻接地。
  - 浮空输入：输入端接的既不是高电平也不是低电平，输入状态为高阻态，即未知。
  - 推挽输出：可以输出高低电平（两个三极管）。
  - 开漏输出：输出低电平，输出高电平要接上拉电阻，上拉能力弱。
  - 复用推挽输出：GPIO口作为第二功能使用。
  - 复用开漏输出：GPIO口作为第二功能使用。

  # stm32的外设

  - 数模转换(ADC)
  - 备份域(BKP)
  - can总线传输（恶劣环境远距离传输）(CAN)
  - 外部中断(EXTI)
  - 闪存(FLASH)
  - 通用IO口(GPIO)
  - I2C通信(I2C)
  - 独立看门狗(IWDG)
  - 复位和时钟控制(RCC)
  - SPI通信(SPI)
  - 串口通信(USART)

  # LDE_GPIO_Config()

  LED_GPIO_Config( )















# FPU

(floating point uint)浮点运算单元

# stm头文件源文件的使用

- startup_stm32f10x_hd.s 汇编启动文件
- stm32f10x.c
- stm32f10x.h
- misc.c 这个文件是用来配置与中断有关的初始化之类的
- stm32f10x_it.c 存放中断服务程序
- stm32f10x_it.h 存放中断服务程序
- stm32f10x_conf.h
- stm32f10x_gpio.c 有关外设的驱动文件（板级支持包是基于这个文件写的）
- stm32f10x_exti.h
- stm32f10x_rcc.c 复位及时钟控制
- core_cm3.c 与内核有关的源文件
- core_cm3.h 与内核有关的头文件

# 开发

在开发中，stm32f10x_gpio.c文件用得非常多，时钟树，引脚图和这个文件几乎在用

# IRQ

(interrupt request)中断请求

# 复用与重映射

- 复用：GPIO口用作AFIO口(Alternate function IO)，需要配置这个GPIO口的第二功能
- 重映射：把原来属于A引脚的复用功能映射到B引脚上使用。（也就是使得B引脚也可以通过配置然后进入本来只能通过A引脚才能进入的地址）

# __WFI和__WFE的区别

WFI是指中断主动向CPU请求中断，而WFE是指把相应的事件标志位置1，需要CPU去查询相应的寄存器。

# stm32有16种中断线

- 汇编注释的写法是加个分号
- EXTI0_IRQHandler
- EXTI1_IRQHandler
- EXTI2_IRQHandler
- EXTI3_IRQHandler
- EXTI4_IRQHandler
- EXIT9_5_IRQHandler
- EXIT15_10_IRQHandler

# 电源

- 睡眠实验：程序正常运行，等待睡眠，触发中断，执行中断服务程序，回到程序继续执行。

# 重定向c库函数

重定向c库函数指的是将原来的c库函数给重新指向新的地方。比如串口中将fputc()函数重定向到串口中，那么所有基于fputc()的函数，比如printf()函数就从向控制台窗口被重定向到串口输出中。

# 中断

中断可以由上升沿，下降沿，上升下降沿触发（需要配置）。 其中，按键产生中断是最简单的。还有串口也可以产生中断，通过对USART的中断模式的选择可以选择通过哪一种方式来触发中断。

# PLL

(Phase Locked Loop)锁相回路/锁相环。用来统一整合时序信号，使内存可以保存资料。许多电子设备要正常工作，必须使外部输入信号和内部振荡脉冲信号相同，锁相环的作用就在于此。

# stm32存在位段，位带别名区

在寻址空间的另一个地方，取一个别名区，从这个地址开始，每一个字（32bits）就对应到SRAM或者IO中的一位。

# DeInit()

(Defaults Init)和这个函数有关的是恢复默认值用的，一般不用

# AT模式

好像进入蓝牙的AT模式，可以设置很多东西 比如设置蓝牙串口通信的波特率为9600，1位停止位，没有校验位：AT+USAT=9600,0,0

- HC-05和HC-06不同，它进入AT模式，可以通过按下模块上方的小黑点按钮，当闪烁灯慢闪的时候，就表示进入AT模式。

# BLT

(Blue Tooth)蓝牙

# 封装中的设定某位

在stm32的自带函数中，比如stm32f10x_rcc.c中对一个外设的时钟使能，它用的方法是先使用宏定义外设的时钟使能位（通过地址映射到宏定义中），然后将与电源有关的寄存器（每个寄存器有32位）也使用宏定义起来。之后就通过if……else语句进行相应操作。

```
if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph; //即RCC_APB2Periph(时钟使能位)为1（这是一个uint32的值），与上整个寄存器的值就等于某位改变，其他位置0
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;    //时钟使能位置0（取反），其他不变
  }
```

# USART_SR

(Univeral Synchronous/Asynchronous Receiver/Transmitter_Status Register)通用同步异步收发状态寄存器。它里面的TXD(transmit data register empty)和TC(transmit complete)的区别在TXD是判断数据寄存器的数据发送到移位寄存器是否发送完毕，而TC是判断数据移位寄存器中的数据是否发送给上位机完毕。

# stm32f10x_h

这个头文件里面定义了stm32外设的所有寄存器（使用typedef结构体的形式）

# 字符串

字符串不是C的某种存储类型（整型，浮点型，数组，指针……），所以在C语言中使用数组来存储字符串。那么如何如何判断一个数组的大小或者如何知道它什么时候结束呢？C中使用空字符('\0')(ANSIS码值为0)来作为数组结束的标志（初始化字符串的时候系统会自动加上去的）。另外，C中每个字符存储在数组中的每个存储单元中，使用的是char型数组，所以每个存储单元为一个字节。

# volatile

C里面的一个关键字，修饰数据类型用的，主要是用来禁止C编译器对变量的优化，因为编译器有可能会将变量的值存入某个寄存器中（副本）（因为程序执行的时候，读取寄存器的值会比读取RAM快），但是，如果这个变量在中断服务程序中被改变的话，中断服务没办法对对寄存器的值进行修改。如果加上volatile，那么程序读取的变量的值就会从地址处出读出，即每次都能读取到变量真正的值。

# 全双工

全双工的意思是收发可同时进行

# RSSI

(Receive Signal Strength Indication)接收的信号强度。主要运用在无线技术中，如广播，蓝牙等。

# 字库

由于英文的字库比较小，所以我们可以把程序放在flash里面，但是由于中文的字库太大，一般有几百K（M3内部的flash有512K）,所以我们把中文的字库放到了SD卡里面。

# OV7725

一帧表示一幅图像，一般每秒超过24帧则人眼无法分辨出来。

# DS18B20

小数部分最多只能表示1位

# 2.4G无线模块的传输

（使用的是NRF24L01芯片）

- 特点：数据传输不大（小容量的数据可以，但是不可以传送视频这些容量大的数据），穿透能力弱
- 串口数据传输，RS485数据传输，区别于RS232。
- RS485是一种接口标准，但是只是规定了接口的电气标准，简单说是物理层的一个标准。它没有对接口插件电缆及传输协议作出规定，所以我们可以在串口标准协议下使用各种协议进行设备之间的通信及设备控制。
- 主机要烧写入程序，从机也要烧写入程序

# RS485电平

（使用芯片：SN75LBC184） RS485芯片可以将TTL电平转换为RS485电平

# LAN

(Local Area Network)局域网。是指在一个特定的区域内，将计算机，外部设备和数据库等连接在一起而形成的一个计算机通信网络。区别于WAN(Wide Area Network)广域网

# 以太网

- 如果要在其他局域网内控制stm32（在另一个局域网里），那么他们的网关应该是相同的。
- 每台电脑都有自己的ip，单片机也可以设置一个单片机自己的ip地址。
- 每个路由器都有自己的一个网关，当笔记本连接到无线局域网的时候，就会得到一个本机的ip,也可以通过cmd找到网关的数值。
- 每台电脑的ip都应该是不一样的，就像我们设置单片机的ip的时候，不能设置和其他人的笔记本具有相同的ip。否则在相同的局域网内，当你将数据ping上去的时候，会发生，当某一台电脑想要控制单片机的时候，却发送数据给其他的具有相同ip的笔记本。
- 通过DOS模式可以远程登陆某一个ip地址，比如，可以远程登陆单片机的ip，然后远程控制单片机。还可以通过http网站上输入ip进行操作。

# 以太网和局域网的区别

局域网讲的只是一个网络的规模，而以太网说的是局域网最通用的一种通信协议标准。

# ping

- ping指的是向一个网址发送数据测试包，判断对方是否有响应并统计响应时间，以此来测试网络。

# OTG

(On-The-G0)是一种可以在设备或者移动设备之间通过USB线进行数据传输的技术。

- 使用USB进行数据传输具有两种方式：

1. 有可以充当host（主机）的设备，比如PC。ISO板子上的USB接口只能充当从机使用（stm32f10x系列不支持OTG技术，stm32f20，stm32f40系列有支持）。
2. 支持OTG技术。

# 红外遥控

- 理论上，红外遥控的接收角度是15°，距离是15米。
- 不同的红外设备（控制电视的，控制空调的）具有不同的波形，而不同的波形是不同的红外设备一开始就固定好了的（就好像已经集成好I2C通信的设备一样），并使用这个波形作为数据传输的方式。而红外接收就必须先了解到红外遥控设备的数据发送方式，并进行具体的解码，然后就可以得到是红外遥控上哪一个按键被按下了，并根据按下的按键执行相应的操作。

# AHB和APB

(Advanced High Performance Bus)系统总线和(Advanced Peripher Bus)外围总线

# EXTI

外部中断的触发有两种类型（模式），即中断触发和事件触发。(Pulse和Pending)

# stm32f10x_rcc.c

1. HSE
2. HSI
3. PLL
4. SystermClock
5. HCLK
6. PCLK
7. IT
8. USBClock
9. OTGClock
10. ADCClock
11. I2CClock
12. LSE
13. LSI
14. RTC

```
15. GetCocksFreq();
```

1. AHB
2. APB
3. BKR
4. CSS(CLock Security Systerm)
5. MCO(Main Clock Output)

```
20. GetFlagStatus();
21. CLearFlag();
22. GetITStatus();
23. ClearITPendingBit()；
```

# timing

定时。time的ing形式

# core_cm3.h

这个函数里面写有与NVIC和SysTick有关的函数

# stm32f10x.h

这个文件里面有关于配置里面两个宏定义的信息。

- USE_STDPERIPH_DRIVER（在第8296-8298行中，有包含stm32f10x_conf.h） :如果定义了这个宏，那么你可以使用st公司为你编写的32库函数，但是如果你没有定义的话，只能自己去操作底层的外设寄存器。
- 这个头文件所包含的头文件：

1. \#include "core_cm3.h"
2. \#include "systerm_stm32f10x.h"
3. \#include <stdint.h>
4. \#include "stm32f10x_conf.h"

# 电源控制

三种电源模式：睡眠模式，停止模式，待机模式

1. 电源管理电源： i.	VDDA供电区域：外设的电源（温度传感器，AD转换器，复位电路，PLL(Phase Locked Loop)） ii.	VDD供电区域：待机电路（唤醒逻辑：IWDG）（带电压调节器） iii.	1.8V核心电源：内核存储器供电区域（内置数字外设） iv.	后备电源区域：带后备寄存器
	. 电源模块： i.	睡眠模式：内核时钟关闭，外设时钟不关闭（进入方式：__WFI(); __WFE():）（唤醒方式：任一中断或者唤醒事件（目前还没用过事件唤醒）） ii.	停止模式：所有时钟都关闭（进入方式：PDDS位和LPDS位+SLEEPDEEP位+ __WFI();或__WFE(); 唤醒方式：任一外部中断（在外部中断寄存器中配置））。由于执行了停止模式，所有的时钟都停止了，所以，醒来的时候要记得配置系统时钟，72MHz，如果还要使用外设记得配置外设的时钟啊。 iii.	待机模式：所有时钟关闭+1.8V核心电源也关闭（进入方式：PDDS位+SLEEPDEEP位+ __WFI();或__WFE(): 唤醒方式：WKUP上升沿；RTC闹钟事件；NRST外部复位；IWDG复位）
	. 电压调节器 （一些模式的选择需要配置电压调节器） i.	运转模式：以正常功耗提供1.8V电源（内存，内核，外设） ii.	停止模式：以低功耗提供1.8V电源（保证寄存器和SRAM和内容不丢失） iii.	待机模式：不供电。除了备份电路和备份域内容外，寄存器和SRAM的内容全部丢失。





# 位图和矢量图

位图是由像素点组成的图像，而矢量图是由数学矢量构成的图形。两者最大的区别就是位图在图像放大的时候会失真，而矢量图在图像放大的时候不会失真。我的理解是使用数学矢量的时候，它不是有方向吗，根据初定好的方向，那么它的图像会随着它的矢量的变化而变化，意思就是它不是静态的，而是某种程度上的动态，所以我们看到的矢量图不会失真。